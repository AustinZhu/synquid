- No spurious branches
- Other data types
- Polymorphism
- Higher-order functions
- Abstract refinements

- Optimize	
	- Search strategies (symbolic vs explicit, e-guess caching)
	- Disjoint spaces in the solver

- Make conditions programs

- Figure out assumptions in aggressive prune

- Disjunctive constraints vs. indexed/disjunctive types vs. abstracting leaf types with smart constraint manipulation (just not all at once!)
- Block infeasible combinations of symbol qualifiers right away; can we achieve more with search space manipulation?
- Do not treat neg assumptions as RHS (this enables vacuous branches!)

- Evaluation of disjunctive constraints: keep track of valid/invalid for each conjunct

- Parser for types and templates

