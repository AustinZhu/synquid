- Fix type abstraction bug: propagate existential variables upwards
- Incremental pruning (compare efficiency)

	- max3: too many recursive calls
	- replicate: matches nil

- Search strategies: stream vs. increasing bounds, symbolic vs. explicit
- Disjoint spaces in the solver
- Compare my times to Steve

- Bidirectional type-checking:
	- Modify solver to return candidates
	- Modify constraint generator: split into I-propagation/E-guessing inside a backtracking monad with incremental pruning
- Polymorphism
	- Implement shape unification
	- Use it E-guessing
- Additional pruning (when to apply matches and constructors?)
- Higher-order functions
- Abstract refinements
- Make conditions programs
- Other Data types

- Figure out assumptions in aggressive prune

- Disjunctive constraints vs. indexed/disjunctive types vs. abstracting leaf types with smart constraint manipulation (just not all at once!)
- Block infeasible combinations of symbol qualifiers right away; can we achieve more with search space manipulation?
- Do not treat neg assumptions as RHS (this enables vacuous branches!)

- Evaluation of disjunctive constraints: keep track of valid/invalid for each conjunct

- Parser for types and templates

