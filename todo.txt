- Bidirectional type-checking:
	- Modify solver to return candidates
	- Modify constraint generator: split into I-propagation/E-guessing inside a backtracking monad with incremental pruning
- Unit propagation in E-guessing the left-most term	
- Polymorphism
	- Implement shape unification
	- Use it E-guessing
- Additional pruning (when to apply matches and constructors?)
- Higher-order functions
- Abstract refinements
- Make conditions programs
- Other Data types

- Figure out assumptions in aggressive prune

- Disjunctive constraints vs. indexed/disjunctive types vs. abstracting leaf types with smart constraint manipulation (just not all at once!)
- Block infeasible combinations of symbol qualifiers right away; can we achieve more with search space manipulation?
- Do not treat neg assumptions as RHS (this enables vacuous branches!)

- Evaluation of disjunctive constraints: keep track of valid/invalid for each conjunct

- Parser for types and templates

