- When instantiating a symbol, also substitute type vars inside the refinements
- Propagate env out of generateI as well, and use generateI for arguments? Advantage: can generate lambdas as arguments
- Fix symbol instantiations (in abstract symbols, should be one per leaf constraint)

- E-guess caching

- Abstract refinements


- Make conditions programs

- Figure out assumptions in aggressive prune

- Disjunctive constraints vs. indexed/disjunctive types vs. abstracting leaf types with smart constraint manipulation (just not all at once!)
- Block infeasible combinations of symbol qualifiers right away; can we achieve more with search space manipulation?
- Do not treat neg assumptions as RHS (this enables vacuous branches!)

- Evaluation of disjunctive constraints: keep track of valid/invalid for each conjunct

- Parser for types and templates

